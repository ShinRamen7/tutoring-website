Summary:
  - Directory: .
  - Files processed: 7
  - Total lines: 732
  - Duration: 0.02 seconds

================================================================================

Directory Structure:

├── models/
│   ├── Session.js
│   └── Tutor.js
├── public/
│   └── style.css
├── views/
│   ├── CodeView.js
├── codebase-review.js
├── package.json
└── server.js

Files extracted:
codebase-review.js (starts at line 28)
models/Session.js (starts at line 202)
models/Tutor.js (starts at line 221)
package.json (starts at line 240)
public/style.css (starts at line 268)
server.js (starts at line 461)
views/CodeView.js (starts at line 635)

================================================================================

File: codebase-review.js (starts at line 28)

const fs = require("fs").promises;
const path = require("path");
const { performance } = require("perf_hooks");

const IGNORED_DIRS = ["node_modules", "build", "dist", ".git"];
const IGNORED_FILES = [
  ".DS_Store",
  ".gitignore",
  "package-lock.json",
  "yarn.lock",
];
const IMPORTANT_EXTENSIONS = [
  ".js",
  ".jsx",
  ".ts",
  ".tsx",
  ".py",
  ".css",
  ".html",
  ".md",
  ".json",
];
const FILE_DELIMITER = "\n\n" + "=".repeat(80) + "\n\n";

async function generateTree(directory, prefix = "") {
  let tree = "";
  const entries = await fs.readdir(directory, { withFileTypes: true });
  const files = entries.filter((entry) => entry.isFile());
  const directories = entries.filter((entry) => entry.isDirectory());

  for (const [index, dir] of directories.entries()) {
    if (!IGNORED_DIRS.includes(dir.name)) {
      const isLast = index === directories.length - 1 && files.length === 0;
      tree += `${prefix}${isLast ? "└── " : "├── "}${dir.name}/\n`;
      tree += await generateTree(
        path.join(directory, dir.name),
        `${prefix}${isLast ? "    " : "│   "}`
      );
    }
  }

  for (const [index, file] of files.entries()) {
    if (!IGNORED_FILES.includes(file.name)) {
      const ext = path.extname(file.name);
      if (IMPORTANT_EXTENSIONS.includes(ext)) {
        const isLast = index === files.length - 1;
        tree += `${prefix}${isLast ? "└── " : "├── "}${file.name}\n`;
      }
    }
  }

  return tree;
}

async function readCodebaseFiles(directory) {
  let output = "";
  let fileList = [];
  let fileCount = 0;
  let totalLines = 0;
  const startTime = performance.now();

  // Generate summary and directory structure first
  const tree = await generateTree(directory);
  const summary = `Summary:
  - Directory: ${directory}
  - Files processed: ${fileCount}
  - Total lines: ${totalLines}
  - Duration: 0.00 seconds

${"=".repeat(80)}

`;

  const fileListString =
    "Files extracted:\n" +
    fileList.join("\n") +
    "\n\n" +
    "=".repeat(80) +
    "\n\n";

  // Calculate the initial offset dynamically
  const initialContent =
    summary + "Directory Structure:\n\n" + tree + "\n" + fileListString;
  const initialOffset = initialContent.split("\n").length;

  let currentLine = initialOffset + 1; // Start after the initial offset

  async function processDirectory(dir) {
    const entries = await fs.readdir(dir, { withFileTypes: true });

    for (const entry of entries) {
      const fullPath = path.join(dir, entry.name);

      if (entry.isDirectory() && !IGNORED_DIRS.includes(entry.name)) {
        await processDirectory(fullPath);
      } else if (entry.isFile() && !IGNORED_FILES.includes(entry.name)) {
        const ext = path.extname(entry.name);
        if (IMPORTANT_EXTENSIONS.includes(ext)) {
          const relativePath = path.relative(directory, fullPath);
          const content = await fs.readFile(fullPath, "utf8");
          const lines = content.split("\n").length;
          fileList.push(`${relativePath} (starts at line ${currentLine})`);
          output += `File: ${relativePath} (starts at line ${currentLine})\n\n`;
          currentLine += 2; // For the header and empty line
          output += content;
          currentLine += lines;
          output += FILE_DELIMITER;
          currentLine += FILE_DELIMITER.split("\n").length;
          fileCount++;
          totalLines += lines;
        }
      }
    }
  }

  await processDirectory(directory);

  const endTime = performance.now();
  const duration = ((endTime - startTime) / 1000).toFixed(2);

  const finalSummary = `Summary:
  - Directory: ${directory}
  - Files processed: ${fileCount}
  - Total lines: ${totalLines}
  - Duration: ${duration} seconds

${"=".repeat(80)}

`;

  const finalFileListString =
    "Files extracted:\n" +
    fileList.join("\n") +
    "\n\n" +
    "=".repeat(80) +
    "\n\n";
  const finalTree = await generateTree(directory);

  return (
    finalSummary +
    "Directory Structure:\n\n" +
    finalTree +
    "\n" +
    finalFileListString +
    output.trim()
  );
}

async function main() {
  const directory = process.argv[2];
  if (!directory) {
    console.error("Please provide a directory path as an argument.");
    process.exit(1);
  }

  try {
    const result = await readCodebaseFiles(directory);
    const outputPath = path.join(directory, "codebase_review.txt");
    await fs.writeFile(outputPath, result);
    console.log(`Codebase contents have been written to ${outputPath}`);
  } catch (error) {
    console.error("An error occurred:", error);
    process.exit(1);
  }
}

main();

================================================================================

File: models/Session.js (starts at line 202)

const mongoose = require('mongoose');

const sessionSchema = new mongoose.Schema({
    studentName: String,
    tutorName: String,
    date: String,
    time: String
});

module.exports = mongoose.model('Session', sessionSchema);



================================================================================

File: models/Tutor.js (starts at line 221)

const mongoose = require('mongoose');

const tutorSchema = new mongoose.Schema({
    name: String,
    university: String,
    bio: String,
    photoUrl: String // URL for their headshot
});

module.exports = mongoose.model('Tutor', tutorSchema);



================================================================================

File: package.json (starts at line 240)

{
  "name": "tutoring-website",
  "version": "1.0.0",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "description": "",
  "dependencies": {
    "body-parser": "^2.2.0",
    "dotenv": "^16.5.0",
    "ejs": "^3.1.10",
    "express": "^5.1.0",
    "express-session": "^1.18.1",
    "mongoose": "^8.13.2"
  }
}


================================================================================

File: public/style.css (starts at line 268)

body {
    font-family: Arial, sans-serif;
    background-color: #f0f8ff;
    text-align: center;
    margin: 0;
    padding: 0;
  }
  
  h1 {
    color: #333;
    margin-top: 50px;
  }
  
  form {
    background: white;
    padding: 20px;
    margin: 30px auto;
    display: inline-block;
    border-radius: 10px;
    box-shadow: 0px 0px 10px gray;
  }
  
  input, button {
    padding: 10px;
    margin: 10px;
    border-radius: 5px;
    border: 1px solid #ccc;
  }
  
  a {
    display: inline-block;
    margin-top: 20px;
    text-decoration: none;
    color: #0066cc;
  }
  
  a:hover {
    text-decoration: underline;
  }
  

  /* Make the form shrink nicely on small screens */
form {
    width: 90%;
    max-width: 400px;
  }
  
  /* Make input fields and button take full width */
  input, button {
    width: 90%;
    max-width: 300px;
    font-size: 16px;
  }
  
  /* Stack links vertically on small screens */
  @media (max-width: 600px) {
    a {
      display: block;
      margin: 10px 0;
      font-size: 18px;
    }
  }
  
  /* Navbar Styles */
.navbar {
    background-color: #333;
    padding: 10px 20px;
    color: white;
    display: flex;
    justify-content: space-between;
    align-items: center;
    flex-wrap: wrap;
  }
  
  .navbar .logo {
    font-size: 24px;
    font-weight: bold;
  }
  
  .navbar .nav-links {
    display: flex;
    gap: 20px;
  }
  
  .navbar .nav-links a {
    color: white;
    text-decoration: none;
    font-size: 18px;
  }
  
  .navbar .nav-links a:hover {
    text-decoration: underline;
  }
  
  /* Make Navbar Mobile Friendly */
  @media (max-width: 600px) {
    .navbar {
      flex-direction: column;
      align-items: flex-start;
    }
    
    .navbar .nav-links {
      flex-direction: column;
      width: 100%;
    }
  
    .navbar .nav-links a {
      padding: 10px 0;
    }
  }
  
  /* Hero Section */
.hero {
    background: url('https://images.unsplash.com/photo-1523240795612-9a054b0db644?ixlib=rb-4.0.3&auto=format&fit=crop&w=1950&q=80') no-repeat center center/cover;
    color: white;
    text-align: center;
    padding: 100px 20px;
  }
  
  .hero h1 {
    font-size: 48px;
    margin-bottom: 20px;
  }
  
  .hero p {
    font-size: 24px;
    margin-bottom: 30px;
  }
  
  .hero-btn {
    background-color: #ff6600;
    color: white;
    padding: 15px 30px;
    font-size: 18px;
    text-decoration: none;
    border-radius: 30px;
    transition: background-color 0.3s;
  }
  
  .hero-btn:hover {
    background-color: #cc5200;
  }
  
  /* Responsive Hero Section */
  @media (max-width: 600px) {
    .hero h1 {
      font-size: 32px;
    }
    .hero p {
      font-size: 18px;
    }
  }
  
  /* Tutor Cards */
.tutor-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
    gap: 20px;
    padding: 30px;
  }
  
  .tutor-card {
    background: white;
    padding: 20px;
    border-radius: 10px;
    text-align: center;
    box-shadow: 0 0 10px rgba(0,0,0,0.1);
  }
  
  .tutor-card img {
    width: 120px;
    height: 120px;
    border-radius: 50%;
    object-fit: cover;
    margin-bottom: 15px;
  }
  
  .tutor-card h2 {
    margin: 10px 0 5px;
  }
  
  .tutor-card h4 {
    margin: 0 0 15px;
    color: gray;
  }
  

================================================================================

File: server.js (starts at line 461)

const ADMIN_USERNAME = 'admin';
const ADMIN_PASSWORD = 'password123';

require('dotenv').config();
const express = require('express');
const mongoose = require('mongoose');
const bodyParser = require('body-parser');

const Session = require('./models/Session');

const app = express();

// Middlewares
app.use(bodyParser.urlencoded({ extended: true }));
app.set('view engine', 'ejs');
app.use(express.static('public'));

const session = require('express-session');

// Setup session
app.use(session({
    secret: 'yourSecretKey',  // (make it something random and long later)
    resave: false,
    saveUninitialized: true
}));

// Connect to MongoDB
mongoose.connect(process.env.MONGO_URI, { useNewUrlParser: true, useUnifiedTopology: true })
.then(() => console.log('MongoDB connected'))
.catch((err) => console.log(err));

// Routes
app.get('/', (req, res) => {
    res.render('index');
});

app.get('/book', (req, res) => {
    res.render('book');
});

app.post('/book', async (req, res) => {
    const { studentName, tutorName, date, time } = req.body;
    const newSession = new Session({ studentName, tutorName, date, time });
    await newSession.save();
    res.redirect('/');
});

app.get('/contact', (req, res) => {
    res.render('contact');
});

app.get('/sessions', async (req, res) => {
    const sessions = await Session.find();
    res.render('sessions', { sessions });
});

const Tutor = require('./models/Tutor');

app.get('/tutors', async (req, res) => {
    const tutors = await Tutor.find();
    res.render('tutors', { tutors });
});

// Admin - Show Add Tutor Form
app.get('/admin/add-tutor', (req, res) => {
    res.render('add-tutor');
});

// Admin - Handle Form Submission
app.post('/admin/add-tutor', async (req, res) => {
    const { name, university, bio, photoUrl } = req.body;
    const newTutor = new Tutor({ name, university, bio, photoUrl });
    await newTutor.save();
    res.redirect('/tutors'); // After adding, show all tutors
});

// Start server
const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
    console.log(`Server is running on port ${PORT}`);
});

// Admin Login Page
app.get('/admin/login', (req, res) => {
    res.render('login');
});

// Admin Login Submission
app.post('/admin/login', (req, res) => {
    const { username, password } = req.body;
    if (username === ADMIN_USERNAME && password === ADMIN_PASSWORD) {
        req.session.loggedIn = true;
        res.redirect('/admin/add-tutor');
    } else {
        res.send('Invalid credentials. <a href="/admin/login">Try again</a>');
    }
});

// Admin Logout
app.get('/admin/logout', (req, res) => {
    req.session.destroy();
    res.redirect('/admin/login');
});

// Protect Admin Add Tutor Page
app.get('/admin/add-tutor', (req, res) => {
    if (req.session.loggedIn) {
        res.render('add-tutor');
    } else {
        res.redirect('/admin/login');
    }
});

// Protect Admin Tutor Submission
app.post('/admin/add-tutor', async (req, res) => {
    if (req.session.loggedIn) {
        const { name, university, bio, photoUrl } = req.body;
        const newTutor = new Tutor({ name, university, bio, photoUrl });
        await newTutor.save();
        res.redirect('/tutors');
    } else {
        res.redirect('/admin/login');
    }
});

// Admin Dashboard - View All Tutors
app.get('/admin/dashboard', async (req, res) => {
    if (req.session.loggedIn) {
        const tutors = await Tutor.find();
        res.render('admin-dashboard', { tutors });
    } else {
        res.redirect('/admin/login');
    }
});

// Admin - Show Edit Tutor Form
app.get('/admin/edit-tutor/:id', async (req, res) => {
    if (req.session.loggedIn) {
        const tutor = await Tutor.findById(req.params.id);
        res.render('edit-tutor', { tutor });
    } else {
        res.redirect('/admin/login');
    }
});

// Admin - Handle Edit Form Submission
app.post('/admin/edit-tutor/:id', async (req, res) => {
    if (req.session.loggedIn) {
        const { name, university, bio, photoUrl } = req.body;
        await Tutor.findByIdAndUpdate(req.params.id, { name, university, bio, photoUrl });
        res.redirect('/admin/dashboard');
    } else {
        res.redirect('/admin/login');
    }
});


// Admin - Delete Tutor
app.post('/admin/delete-tutor/:id', async (req, res) => {
    if (req.session.loggedIn) {
        await Tutor.findByIdAndDelete(req.params.id);
        res.redirect('/admin/dashboard');
    } else {
        res.redirect('/admin/login');
    }
});


================================================================================

File: views/CodeView.js (starts at line 635)

const fs = require("fs").promises;
const path = require("path");
const { performance } = require("perf_hooks");

const IGNORED_DIRS = ["node_modules", "build", "dist", ".git"];
const IGNORED_FILES = [
  ".DS_Store",
  ".gitignore",
  "package-lock.json",
  "yarn.lock",
];
const IMPORTANT_EXTENSIONS = [
  ".js",
  ".jsx",
  ".ts",
  ".tsx",
  ".py",
  ".css",
  ".html",
  ".md",
  ".json",
];
const FILE_DELIMITER = "\n\n" + "=".repeat(80) + "\n\n";

async function generateTree(directory, prefix = "") {
  let tree = "";
  const entries = await fs.readdir(directory, { withFileTypes: true });
  const files = entries.filter((entry) => entry.isFile());
  const directories = entries.filter((entry) => entry.isDirectory());

  for (const [index, dir] of directories.entries()) {
    if (!IGNORED_DIRS.includes(dir.name)) {
      const isLast = index === directories.length - 1 && files.length === 0;
      tree += `${prefix}${isLast ? "└── " : "├── "}${dir.name}/\n`;
      tree += await generateTree(
        path.join(directory, dir.name),
        `${prefix}${isLast ? "    " : "│   "}`
      );
    }
  }

  for (const [index, file] of files.entries()) {
    if (!IGNORED_FILES.includes(file.name)) {
      const ext = path.extname(file.name);
      if (IMPORTANT_EXTENSIONS.includes(ext)) {
        const isLast = index === files.length - 1;
        tree += `${prefix}${isLast ? "└── " : "├── "}${file.name}\n`;
      }
    }
  }

  return tree;
}

async function readCodebaseFiles(directory) {
  let output = "";
  let fileList = [];
  let fileCount = 0;
  let totalLines = 0;
  const startTime = performance.now();

  // Generate summary and directory structure first
  const tree = await generateTree(directory);
  const summary = `Summary:
  - Directory: ${directory}
  - Files processed: ${fileCount}
  - Total lines: ${totalLines}
  - Duration: 0.00 seconds

${"=".repeat(80)}

`;

  const fileListString =
    "Files extracted:\n" +
    fileList.join("\n") +
    "\n\n" +
    "=".repeat(80) +
    "\n\n";

  // Calculate the initial offset dynamically
  const initialContent =
    summary + "Directory Structure:\n\n" + tree + "\n" + fileListString;
  const initialOffset = initialContent.split("\n").length;

  let currentLine = initialOffset + 1; // Start after the initial offset

  async function processDirectory(dir) {
    const entries = await fs.readdir(dir, { withFileTypes: true });

    for (const entry of entries) {
      const fullPath = path.join(dir, entry.name);

      if (entry.isDirectory() && !IGNORED_DIRS.includes(entry.name)) {
        await processDirectory(fullPath);
      } else if (entry.isFile() && !IGNORED_FILES.includes(entry.name)) {
        const ext = path.extname(entry.name);
        if (IMPORTANT_EXTENSIONS.includes(ext)) {
          const relativePath = path.relative(directory, fullPath);
          const content = await fs.readFile(fullPath, "utf8");
          const lines = content.split("\n").length;
          fileList.push(`${relativePath} (starts at line ${currentLine})`);
          output += `File: ${relativePath} (starts at line ${currentLine})\n\n`;
          currentLine += 2; // For the header and empty line
          output += content;
          currentLine += lines;
          output += FILE_DELIMITER;
          currentLine += FILE_DELIMITER.split("\n").length;
          fileCount++;
          totalLines += lines;
        }
      }
    }
  }

  await processDirectory(directory);

  const endTime = performance.now();
  const duration = ((endTime - startTime) / 1000).toFixed(2);

  const finalSummary = `Summary:
  - Directory: ${directory}
  - Files processed: ${fileCount}
  - Total lines: ${totalLines}
  - Duration: ${duration} seconds

${"=".repeat(80)}

`;

  const finalFileListString =
    "Files extracted:\n" +
    fileList.join("\n") +
    "\n\n" +
    "=".repeat(80) +
    "\n\n";
  const finalTree = await generateTree(directory);

  return (
    finalSummary +
    "Directory Structure:\n\n" +
    finalTree +
    "\n" +
    finalFileListString +
    output.trim()
  );
}

async function main() {
  const directory = process.argv[2];
  if (!directory) {
    console.error("Please provide a directory path as an argument.");
    process.exit(1);
  }

  try {
    const result = await readCodebaseFiles(directory);
    const outputPath = path.join(directory, "codebase_review.txt");
    await fs.writeFile(outputPath, result);
    console.log(`Codebase contents have been written to ${outputPath}`);
  } catch (error) {
    console.error("An error occurred:", error);
    process.exit(1);
  }
}

main();

================================================================================